Object Oriented Programming

OOP is a programming paradigm that organizes software design around objects, rather than functions or logic.

An object is an instance of a class, which bundles data (fields/attributes) and behaviour (methods/functions) together.

OOP is a methodology for designing and building software using objects that interact with each other, modelling real-world entities,
and encapsulating data and behaviour.

There are four main pillars of OOP:

1. Encapsulation

Definition: Hiding the internal state of an object and providing controlled access via methods.

Benefit: Improves security and maintainability.

2.  Abstraction

Definition: Hiding implementation details and exposing only essential functionality.

Benefit: Lets you program to interfaces/abstract types, not specific implementations.

3.  Inheritance

Definition: Mechanism by which one class (subclass) acquires fields and methods of another class (superclass).

Benefit: Promotes code reuse and a hierarchical relationship.

4.  Polymorphism

Definition: Ability of an object to take many forms; the same method call can behave differently depending on the object.

Benefit: Enhances flexibility and extensibility.





---- Shallow Copy and Deep Copy -------------


A shallow copy of an object is a copy where the fields of the object are copied as-is, including references.
In other words, the top-level object is duplicated, but the objects it refers to are not; 
they are shared between the original and the copy.

Only the references are copied, not the actual objects they point to.
Modifying a nested object in the copy will affect the original.

A deep copy of an object is a copy where all objects are duplicated recursively, not just the top-level object.
The copy and the original are completely independent, including all nested objects.

Modifying the copy does not affect the original.


-------------------   Static Non Static ------------------------------------------


A static member (variable or method) belongs to the class itself, rather than to any particular instance of the class.
Static members are shared across all instances of the class.

Declared using the static keyword.

Exists once per class, not per object.

Can be accessed without creating an instance of the class.

Typical uses: constants, utility methods, counters, shared resources.



A non-static (instance) member belongs to each individual object of the class.
Each object has its own copy of instance variables and can access instance methods.

Declared without static.

Exists once per object.

Can only be accessed through an object reference.

Typical uses: object-specific data, behaviors.



---------------------------  Method Overriding         Method Overloading ------------------------------------------

Method overloading in Java is a compile-time polymorphism feature that allows multiple methods
in the same class (or subclass) to have the same name but 
different parameter lists (different number, types, or order of parameters). 
The return type alone cannot distinguish overloaded methods.

Happens within the same class (or between parent and child if methods don’t conflict).

Distinguished by the method signature (parameters).

Decided at compile-time (static binding).

Improves readability by using the same method name for related tasks.

class MathUtils {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; } // Overloaded
    int add(int a, int b, int c) { return a + b + c; } // Overloaded
}


Method overriding in Java is a runtime polymorphism feature that allows a subclass to provide a 
specific implementation of a method that is already defined in its superclass. 
The overriding method must have the same name, return type (or covariant), and parameters as the method in the superclass.


Happens across inheritance hierarchy (parent → child).

Requires an IS-A relationship (inheritance).

The method in subclass replaces the superclass version when called on subclass objects.

Resolved at runtime (dynamic dispatch).

Marked with @Override annotation (recommended, but not mandatory).

class Vehicle {
    void start() {
        System.out.println("Vehicle starts");
    }
}

class Car extends Vehicle {
    @Override
    void start() {
        System.out.println("Car starts with key"); // Overridden
    }
}





----------------------------------------      Exception Handling          --------------------------------------



Exception Handling in Java is a mechanism to detect, handle, 
and recover from runtime errors (exceptions) in a controlled manner, without abruptly terminating the program.


1. Exception

An event that disrupts the normal flow of a program.

Occurs during runtime (e.g., dividing by zero, accessing invalid array index, null reference).

2. Types of Exceptions

Checked Exceptions:

Checked at compile-time.

Must be either caught (try-catch) or declared with throws.

Example: IOException, SQLException.

Unchecked Exceptions (Runtime Exceptions):

Occur at runtime, not checked at compile time.

Typically caused by programming errors (null, out of bounds, etc.).

Example: NullPointerException, ArrayIndexOutOfBoundsException.

Errors:

Serious problems beyond programmer control.

Example: OutOfMemoryError, StackOverflowError.


3. Keywords in Exception Handling

try – block of code that may throw an exception.

catch – block that handles the exception.

finally – block that always executes (cleanup).

throw – used to explicitly throw an exception.

throws – declares exceptions a method may throw.




