Object Oriented Programming

OOP is a programming paradigm that organizes software design around objects, rather than functions or logic.

An object is an instance of a class, which bundles data (fields/attributes) and behaviour (methods/functions) together.

OOP is a methodology for designing and building software using objects that interact with each other, modelling real-world entities,
and encapsulating data and behaviour.

There are four main pillars of OOP:

1. Encapsulation

Definition: Hiding the internal state of an object and providing controlled access via methods.

Benefit: Improves security and maintainability.

2.  Abstraction

Definition: Hiding implementation details and exposing only essential functionality.

Benefit: Lets you program to interfaces/abstract types, not specific implementations.

3.  Inheritance

Definition: Mechanism by which one class (subclass) acquires fields and methods of another class (superclass).

Benefit: Promotes code reuse and a hierarchical relationship.

4.  Polymorphism

Definition: Ability of an object to take many forms; the same method call can behave differently depending on the object.

Benefit: Enhances flexibility and extensibility.





---- Shallow Copy and Deep Copy -------------


A shallow copy of an object is a copy where the fields of the object are copied as-is, including references.
In other words, the top-level object is duplicated, but the objects it refers to are not; 
they are shared between the original and the copy.

Only the references are copied, not the actual objects they point to.
Modifying a nested object in the copy will affect the original.

A deep copy of an object is a copy where all objects are duplicated recursively, not just the top-level object.
The copy and the original are completely independent, including all nested objects.

Modifying the copy does not affect the original.


-------------------   Static Non Static ------------------------------------------


A static member (variable or method) belongs to the class itself, rather than to any particular instance of the class.
Static members are shared across all instances of the class.

Declared using the static keyword.

Exists once per class, not per object.

Can be accessed without creating an instance of the class.

Typical uses: constants, utility methods, counters, shared resources.



A non-static (instance) member belongs to each individual object of the class.
Each object has its own copy of instance variables and can access instance methods.

Declared without static.

Exists once per object.

Can only be accessed through an object reference.

Typical uses: object-specific data, behaviors.



---------------------------  Method Overriding         Method Overloading ------------------------------------------

Method overloading in Java is a compile-time polymorphism feature that allows multiple methods
in the same class (or subclass) to have the same name but 
different parameter lists (different number, types, or order of parameters). 
The return type alone cannot distinguish overloaded methods.

Happens within the same class (or between parent and child if methods don’t conflict).

Distinguished by the method signature (parameters).

Decided at compile-time (static binding).

Improves readability by using the same method name for related tasks.

class MathUtils {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; } // Overloaded
    int add(int a, int b, int c) { return a + b + c; } // Overloaded
}


Method overriding in Java is a runtime polymorphism feature that allows a subclass to provide a 
specific implementation of a method that is already defined in its superclass. 
The overriding method must have the same name, return type (or covariant), and parameters as the method in the superclass.


Happens across inheritance hierarchy (parent → child).

Requires an IS-A relationship (inheritance).

The method in subclass replaces the superclass version when called on subclass objects.

Resolved at runtime (dynamic dispatch).

Marked with @Override annotation (recommended, but not mandatory).

class Vehicle {
    void start() {
        System.out.println("Vehicle starts");
    }
}

class Car extends Vehicle {
    @Override
    void start() {
        System.out.println("Car starts with key"); // Overridden
    }
}





----------------------------------------      Exception Handling          --------------------------------------

Throwable is the root superclass for all errors and exceptions in the Java language.
Any object that can be thrown by the JVM or caught by a catch block must be a subclass of Throwable.

Exception Handling in Java is a mechanism to detect, handle, 
and recover from runtime errors (exceptions) in a controlled manner, without abruptly terminating the program.


- Exception

An event that disrupts the normal flow of a program.

Occurs during runtime (e.g., dividing by zero, accessing invalid array index, null reference).

2. Types of throwables

- Checked Exceptions:

Checked at compile-time.

Must be either caught (try-catch) or declared with throws.

Example: IOException, SQLException.

- Unchecked Exceptions (Runtime Exceptions):

Occur at runtime, not checked at compile time.

Typically caused by programming errors (null, out of bounds, etc.).

Example: NullPointerException, ArrayIndexOutOfBoundsException.

- Errors:

Serious problems beyond programmer control.

Example: OutOfMemoryError, StackOverflowError.


3. Keywords in Exception Handling

try – block of code that may throw an exception.

catch – block that handles the exception.

finally – block that always executes (cleanup).

throw – used to explicitly throw an exception.

throws – declares exceptions a method may throw.


------------------------------------------------      Streams  ----------------------------------------


A Stream in Java is a sequence of elements from a source (like a Collection, array, or I/O channel)
that supports functional-style operations to perform bulk data processing in a declarative and parallelizable way.

Does not store data; it’s a pipeline for processing data.

Supports operations like filtering, mapping, reducing, collecting, and grouping.

Can be sequential or parallel.




-------------------------------------------------       Lambdas -------------------------------------------------



A lambda expression in Java is a concise way to represent an anonymous function
(a block of code with parameters and a body) that can be treated as a value, passed around, and executed later.

Syntax
(parameters) -> expression
(parameters) -> { statements; }


(a, b) -> a + b                  // adds two numbers
s -> s.length()                  // returns string length
() -> System.out.println("Hi")   // no parameters




------------------------------------------------- Collections -------------------------------------------


A Collection in Java is an object that represents a group of objects (elements),
known as its members, and provides methods to store, retrieve, manipulate, and traverse these elements efficiently.

Located in java.util package.

Supports dynamic data structures (like lists, sets, maps) as opposed to arrays which have fixed size.

Provides standardized methods for searching, sorting, insertion, deletion, and iteration.




------------------------------------------       Generics    ----------------------------------------------------------



Generics in Java enable parameterized types, 
meaning you can write classes, interfaces, and methods that operate on objects of various types
while providing compile-time type safety and avoiding unnecessary casting.




------------------------------------------       Concurrency    ----------------------------------------------------------



Concurrency is the ability of a system to deal with multiple tasks at once by interleaving their execution, even if they are not literally running at the same time.

It’s about structuring a program so that multiple independent tasks can make progress.

Tasks may share the same CPU core, and the operating system or runtime switches between them (context switching).
Conclusion: Concurrency is about managing multiple tasks at the same time, not necessarily executing them simultaneously.


Parallelism is the ability of a system to execute multiple tasks at the exact same time by utilizing multiple CPU cores or processors.

It’s about physical simultaneous execution.

Usually applied to speed up computation-heavy tasks.
Conclusion: Parallelism is about doing many things at once, leveraging hardware with multiple cores.




A process is an independent program in execution with its own memory space, resources, and system state, managed by the operating system.

Each process has its own heap, stack, data, and code segment.

Processes do not share memory by default → communication requires Inter-Process Communication (IPC) (e.g., sockets, files, shared memory).

Processes are more heavyweight than threads.

Example: Running IntelliJ IDEA and Google Chrome at the same time → each is a separate process.

Conclusion: A process is an independent execution unit with its own memory and resources.


A thread is the smallest unit of execution within a process.

Threads of the same process share memory (heap) and resources, but each thread has its own stack and program counter.

Threads are more lightweight than processes.

Easier and faster to create/switch compared to processes.

Example: Inside Chrome, multiple threads may run — one for rendering a webpage, another for handling user input, another for network requests.

Conclusion: A thread is a lightweight execution unit inside a process that shares memory with other threads in the same process.



A race condition occurs when the behavior or outcome of a program depends on the timing or interleaving of threads/processes accessing shared resources concurrently.

It happens when two or more threads try to read/write a shared variable or resource at the same time.

If the program’s correctness depends on the order of execution, and that order is not guaranteed → race condition.

Results: unpredictable values, corrupted data, or crashes.
Conclusion: A race condition is a concurrency bug where multiple threads compete to access/modify shared data, causing inconsistent or unexpected results.


In Java, synchronized is a keyword that ensures that only one thread at a time can execute a block of code or a method that is synchronized on the same object/monitor lock.

It prevents race conditions by controlling access to shared resources.

When a thread enters a synchronized block/method, it acquires the lock (monitor) of the object.

Other threads trying to enter a synchronized block on the same object must wait until the lock is released.
Conclusion: synchronized provides mutual exclusion and visibility guarantees, making multithreaded code safe.



Thread Life Cycle -

NEW  →  RUNNABLE  →  RUNNING  →  (WAITING / TIMED_WAITING / BLOCKED)  →  TERMINATED


1. New (Created State)

A thread object is created using the Thread class but not yet started.

It is in the NEW state.

Thread t = new Thread(() -> System.out.println("Running"));

Here, the thread t is in the NEW state.

Moves to Runnable when start() is called.


2. Runnable (Ready State)

After calling start(), the thread becomes Runnable.

It is eligible to run, but the thread scheduler decides when it actually runs.

t.start(); // Thread is now RUNNABLE

From here, it may enter Running.


3. Running (Active State)

The thread is actually executing its task (run() method).

Only one thread per core can be in Running state at a time.
After completion or interruption, it can go back to Runnable, Waiting, or Terminated.



4. Waiting (Indefinite Wait)

Thread waits indefinitely until another thread signals it (using notify() or notifyAll()).

It cannot come back automatically; it needs a signal.

synchronized(lock) {
    lock.wait(); // Thread is now WAITING
}

Returns to Runnable when notified.


5. Timed Waiting

Thread waits for a specific amount of time, after which it becomes Runnable again.

Example: sleep(ms), join(ms), wait(ms).

Thread.sleep(1000); // TIMED_WAITING for 1 second



6. Blocked

A thread is blocked when it tries to enter a synchronized block/method but another thread already holds the lock.

Once the lock is released, it becomes Runnable.


7. Terminated (Dead State)

A thread completes execution or is stopped.

Once in this state, it cannot be restarted.

t.join(); // Waits for thread to die


THREAD SAFETY

A class, method, or piece of code is said to be thread-safe if it behaves correctly
when accessed from multiple threads simultaneously, without producing race conditions, corrupted data, or unexpected results.

Conclusion: Thread safety means that multiple threads can safely use the same code 
or object at the same time without breaking program correctness.


VOLATILE

a variable declared as volatile is a shared variable that guarantees:

Visibility → Any write by one thread is immediately visible to other threads.

Ordering (limited) → Prevents certain compiler/CPU optimizations that could reorder reads/writes.

Conclusion: volatile ensures that threads always see the most recent value of a variable, instead of a cached or stale value.
