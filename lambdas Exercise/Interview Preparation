--------------------------------------------------------------------------------------------------------------------------

Basics & Theory

Q1: What is a lambda expression in Java?
A lambda expression is an anonymous function (a block of code without a name) that can be passed around as an object, enabling functional programming in Java.


--------------------------------------------------------------------------------------------------------------------------


Q2: Why were lambdas introduced in Java 8?
To make code more concise, readable, and enable functional programming constructs like Streams and functional interfaces.

--------------------------------------------------------------------------------------------------------------------------



Q3: What is the syntax of a lambda expression?

(parameters) -> expression
(parameters) -> { statements }


Example:

(x, y) -> x + y

--------------------------------------------------------------------------------------------------------------------------



Q4: How are lambda expressions different from anonymous inner classes?

Lambdas are more concise.

Lambdas capture variables differently (effectively final rule).

Lambdas don’t create a separate class file; anonymous inner classes do.

--------------------------------------------------------------------------------------------------------------------------


Q5: Are lambdas objects in Java?
Yes. At runtime, lambdas are represented as instances of functional interfaces.

--------------------------------------------------------------------------------------------------------------------------


Functional Interfaces

Q6: What is a functional interface?
A functional interface is an interface with exactly one abstract method. Lambdas can be used to provide implementations for them.

--------------------------------------------------------------------------------------------------------------------------


Q7: Can a functional interface have default and static methods?
Yes, but it must still have exactly one abstract method.

--------------------------------------------------------------------------------------------------------------------------


Q8: Give examples of built-in functional interfaces in Java.

Predicate<T> → takes one argument, returns boolean.

Function<T,R> → takes one argument, returns result.

Consumer<T> → takes one argument, returns nothing.

Supplier<T> → takes no argument, returns a value.

--------------------------------------------------------------------------------------------------------------------------


Q9: Can you create your own functional interface?
Yes, using @FunctionalInterface annotation to ensure it has only one abstract method.

@FunctionalInterface
interface Calculator {
    int add(int a, int b);
}


--------------------------------------------------------------------------------------------------------------------------


Q10: What happens if you add a second abstract method to a functional interface?
It will not compile if annotated with @FunctionalInterface. Without the annotation, it becomes a normal interface.

--------------------------------------------------------------------------------------------------------------------------


Scope & Variables

Q11: What is the “effectively final” rule in lambdas?
Lambdas can only capture variables from the enclosing scope if they are final or effectively final (not reassigned after initialization).


--------------------------------------------------------------------------------------------------------------------------

Q12: Can a lambda access static and instance variables?
Yes, lambdas can access both static and instance variables of the enclosing class.


--------------------------------------------------------------------------------------------------------------------------

Q13: Can lambdas throw exceptions?
Yes, but they must declare them in the functional interface method signature.


--------------------------------------------------------------------------------------------------------------------------

Q14: Do lambdas introduce a new scope like inner classes?
No, lambdas use the same scope as the enclosing method, unlike anonymous inner classes that create a new scope.


--------------------------------------------------------------------------------------------------------------------------

Q15: What is the type of a lambda expression?
It is inferred from the context (target type) – usually a functional interface.


--------------------------------------------------------------------------------------------------------------------------

Real-World Usage

Q16: How are lambdas used with Streams?
They are passed to Stream operations like map(), filter(), forEach().
Example:

list.stream().filter(x -> x > 10).forEach(System.out::println);


--------------------------------------------------------------------------------------------------------------------------



Q17: Why are lambdas useful in multi-threading?
They make thread creation concise:

new Thread(() -> System.out.println("Running in thread")).start();


--------------------------------------------------------------------------------------------------------------------------



Q18: How do lambdas improve readability in Collections API?
They simplify iteration and transformation:

names.forEach(n -> System.out.println(n));



--------------------------------------------------------------------------------------------------------------------------



Q19: What is the difference between Function and BiFunction in lambdas?

Function<T,R> takes 1 argument, returns 1 result.

BiFunction<T,U,R> takes 2 arguments, returns 1 result.

--------------------------------------------------------------------------------------------------------------------------


Q20: Can lambdas be serialized?
Yes, but only if the target functional interface extends Serializable.


--------------------------------------------------------------------------------------------------------------------------


Tricky Questions

Q21: Can lambdas be recursive?
Yes, but they need a reference to themselves. Example: using UnaryOperator<Integer> with recursion.

--------------------------------------------------------------------------------------------------------------------------



Q22: Can this keyword be used inside a lambda?
Yes, inside a lambda this refers to the enclosing class instance, not the lambda itself.


--------------------------------------------------------------------------------------------------------------------------


Q23: Do lambdas improve performance?
Yes, because they avoid creating separate classes like anonymous inner classes. But they can introduce overhead with excessive use.


--------------------------------------------------------------------------------------------------------------------------

Q24: Can two lambdas with the same code be different objects?
They may or may not be the same object, depending on JVM implementation (caching may occur).

--------------------------------------------------------------------------------------------------------------------------


Q25: How are lambdas implemented internally?
The compiler translates lambdas into private methods and uses the invokedynamic instruction with the LambdaMetafactory.

--------------------------------------------------------------------------------------------------------------------------

Q26: Can we overload methods that use lambdas?
Yes, but it may cause ambiguity if the lambda fits multiple functional interfaces. In such cases, casting is required.


--------------------------------------------------------------------------------------------------------------------------


Q27: How do lambdas handle checked exceptions in Streams?
You must either handle them inside the lambda or wrap them in a runtime exception.


--------------------------------------------------------------------------------------------------------------------------


Q28: Can lambdas replace all anonymous inner classes?
No. Only functional interfaces (1 abstract method) can be replaced. Classes with multiple methods need anonymous classes.

--------------------------------------------------------------------------------------------------------------------------


Q29: What’s the difference between a method reference and a lambda?

Lambda: (x) -> System.out.println(x)

Method reference: System.out::println
Method references are shorthand for lambdas that call an existing method.


--------------------------------------------------------------------------------------------------------------------------


Q30: Why should lambdas be used carefully in large projects?
Because overusing them can reduce readability, debugging can be harder, and excessive chaining may hurt performance.

--------------------------------------------------------------------------------------------------------------------------
